(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{410:function(e,t,n){"use strict";n.r(t);var a=n(55),o=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"_2022-2-7开始-vue3-0将是默认版本"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2022-2-7开始-vue3-0将是默认版本"}},[e._v("#")]),e._v(" 2022/2/7开始 vue3.0将是默认版本")]),e._v(" "),n("ul",[n("li",[e._v("第一步搭建")])]),e._v(" "),n("blockquote",[n("p",[e._v("首先查看当前vue-cli版本号"),n("br"),e._v("\nvue -V 目前我的是@vue/cli 4.5.14")])]),e._v(" "),n("ul",[n("li",[e._v("vue create my-project 创建名为 my-project的项目")]),e._v(" "),n("li",[e._v("之后根据自己习惯安装对应的插件")])]),e._v(" "),n("h3",{attrs:{id:"api"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#api"}},[e._v("#")]),e._v(" API")]),e._v(" "),n("ul",[n("li",[e._v("reactive 创建的响应式数据对象，在对象属性发生变化时，模版是可以 响应更新渲染的")]),e._v(" "),n("li",[e._v("ref() 返回的是一个 value reference （包装对象）。一个包装对象只有一个属性：.value")]),e._v(" "),n("li",[e._v("unref() 是 val = isRef(val) ? val.value : val 的语法糖。")]),e._v(" "),n("li",[e._v("isref() 检查一个值是否为一个 ref 对象。")]),e._v(" "),n("li",[e._v("toRefs() 把一个响应式对象转换成普通对象，该普通对象的每个 property 都是一个 ref ，和响应式对象 property 一一对应。\n并且，当想要从一个组合逻辑函数中返回响应式对象时，用 toRefs 是很有效的，该 API 让消费组件可以 解构 / 扩展（使用 … 操作符）返回的对象，并不会丢失响应性：解构出来不丢失响应性")]),e._v(" "),n("li",[e._v("watchEffect：")]),e._v(" "),n("li",[e._v("1.它是立即执行的，在页面加载时会主动执行一次，来收集依赖")]),e._v(" "),n("li",[e._v("2.不需要传递需要侦听的内容，它可以自动感知代码依赖，只需要传递一个回调函数")]),e._v(" "),n("li",[e._v("3.它不能获取之前数据的值")]),e._v(" "),n("li",[e._v("4.它的返回值用来停止此监听")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const stop = watchEffect( () => {  // 返回值 stop 用来停止监听\n    console.log( data.name )  // 页面加载时执行一次之后，当 data.name 改变时，将会再次执行log\n    setTimeout( () => {\n      stop();  //5秒之后停止此监听\n    }, 5000 )\n  })\n")])])]),n("ul",[n("li",[e._v("watch : （watch也可以在setup中使用）")]),e._v(" "),n("li",[e._v("1.具备一定的惰性 lazy （ 但可配置 immediate , 使其主动）")]),e._v(" "),n("li",[e._v("2.参数可拿到更改之前的值和更改之后的值")]),e._v(" "),n("li",[e._v("3.可以侦听多个数据的变化，用一个侦听器承载")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("watch( () => data.name, (newValue,oldValue) => { //  第一个参数 需要监听的数据\n  console.log(newValue)  // 新值\n  console.log(newValue)  // 旧值\n}，{ immediate: true }) //  第三个参数可接受配置项\n\nwatch( [() => data.name, () => data.age], ([newName, newAge], [oldName, oldAge]) => { \n  console.log(newName, newAge)  // 新值\n  console.log(oldName, oldAge)  // 旧值\n}) \n\n")])])]),n("ul",[n("li",[e._v("computed() 用来创建计算属性，返回值是一个 ref() 实例")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const count = ref(1)\n\n// 创建一个 computed 计算属性，传入一个对象\nconst bigCount = computed({\n    // 取值函数\n    get: () => (count.value + 1),\n    // 赋值函数\n    set: val => {\n      count.value = val - 1\n    }\n})\n\n// 给计算属性赋值的操作，会触发 set 函数\nbigCount.value = 9\n// 触发 set 函数后，count 的值会被更新\nconsole.log(count.value) // 8\n\n")])])]),n("ul",[n("li",[e._v("readonly()")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const state = reactive({ count: 0 })\n\nconst copy = readonly(state)\n\nwatchEffect(() => {\n  // 依赖追踪\n  console.log(copy.count)\n})\n\n// state 上的修改会触发 copy 上的侦听\nstate.count++\n\n// 这里只读属性不能被修改\ncopy.count++ // warning!\n\n")])])]),n("h3",{attrs:{id:"钩子函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#钩子函数"}},[e._v("#")]),e._v(" 钩子函数")]),e._v(" "),n("ul",[n("li",[e._v("beforeCreate -> 使用 setup()")]),e._v(" "),n("li",[e._v("created -> 使用 setup(props, { attrs, slots, emit, expose })")])]),e._v(" "),n("blockquote",[n("p",[e._v("props 是响应式的，你不能使用 ES6 解构，因为它会消除 prop 的响应性。如果需要解构 prop，可以通过使用 setup 函数中的 toRefs 来完成此操作"),n("br"),e._v("\nconst { title } = toRefs(props)"),n("br"),e._v("\nconsole.log(title.value)")])]),e._v(" "),n("blockquote",[n("p",[e._v("对应vue2的 this.$attrs, this.$slots, this.$emit,\nexpose 使用")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// comp-a.vue\nsetup(props, { attrs, slots, emit, expose }) {\n    const observed = reactive({\n      a: 1\n    })\n    function setObservedA(value) {\n      observed.a = value\n    }\n    expose({\n      setObservedA\n    })\n    return {\n      observed,\n    }\n  }\n\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// comp-b.vue\n{\n  template: `\n    <comp-a ref="compa" />\n  `,\n  setup() {\n    const compa = ref(null)\n    onMounted(() => {\n      // comp-a 调用 expose 之后, 父组件 ref 拿到的结果为调用 expose 时的参数。而不再是组件实例了\n      compa.value.setObservedA(2)\n    })\n    return {\n      compa\n    }\n  }\n}\n\n')])])]),n("ul",[n("li",[e._v("beforeMount -> onBeforeMount")]),e._v(" "),n("li",[e._v("mounted -> onMounted")]),e._v(" "),n("li",[e._v("beforeUpdate -> onBeforeUpdate")]),e._v(" "),n("li",[e._v("updated -> onUpdated")]),e._v(" "),n("li",[e._v("beforeDestroy -> onBeforeUnmount")]),e._v(" "),n("li",[e._v("destroyed -> onUnmounted")]),e._v(" "),n("li",[e._v("errorCaptured -> onErrorCaptured")])]),e._v(" "),n("blockquote",[n("p",[e._v("错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("errorCaptured (err, vm, info) {\n    const error = `${err.stack}\\n\\nfound in ${info} of component`\n    return false\n  }\n\n")])])]),n("ul",[n("li",[e._v("onRenderTracked  // 类似散弹枪 检查全部依赖性导致组件重新渲染")]),e._v(" "),n("li",[e._v("onRenderTriggered // 类似狙击枪 检查哪个依赖性导致组件重新渲染")])])])}),[],!1,null,null,null);t.default=o.exports}}]);